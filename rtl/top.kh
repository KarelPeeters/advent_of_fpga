import common.[char, Point as PointGeneral, axi_stream];
import string.[parse_points, int_to_chars];
import xilinx_uram.[uram, uram_port];
import core.core;

module top_generic(
    MAX_POINT_COUNT: uint,
    COORD_LIMIT: natural,
    RAM_PIPELINE: natural,
    CORE_WIDTH: natural,
) ports(
    clk: in clock,
    rst: in async bool,

    sync(clk, rst) {
        input: interface axi_stream(char).input,
        output: interface axi_stream(char).output,
    }
) {
    type Coord = uint(0..COORD_LIMIT);
    type Point = PointGeneral(Coord);
    const AREA_LIMIT = COORD_LIMIT**2 + 2;
    type Area = uint(0..AREA_LIMIT);

    wire input_points: interface axi_stream(Tuple(bool, Point));
    wire output_ints: interface axi_stream(Area);

    instance parse_points(M=COORD_LIMIT) ports(clk, rst, input, output=input_points);
    instance core(
        MAX_POINT_COUNT=MAX_POINT_COUNT,
        COORD_LIMIT=COORD_LIMIT,
        RAM_PIPELINE=RAM_PIPELINE,
        CORE_WIDTH=CORE_WIDTH,
    ) ports(
        clk,
        rst,
        input_points=input_points,
        output_area=output_ints,
    );
    instance int_to_chars(M=AREA_LIMIT) ports(clk, rst, input=output_ints, output);
}

module top ports(
    clk: in clock,
    rst: in async bool,

    sync(clk, rst) {
        input: interface axi_stream(char).input,
        output: interface axi_stream(char).output,
    }
) {
    instance top_generic(
        MAX_POINT_COUNT=1024,
        COORD_LIMIT=10**5,
        RAM_PIPELINE=7,
        CORE_WIDTH=4,
    ) ports(clk, rst, input, output);
}
