import common.[char, Point as PointGeneral, axi_stream];
import string.[parse_points, int_to_chars];
import xilinx_uram.[uram, uram_port];

pub module core(MAX_POINT_COUNT: natural, COORD_LIMIT: natural, RAM_PIPELINE: natural) ports(
    type Coord = uint(0..COORD_LIMIT);
    type Point = PointGeneral(Coord);
    const AREA_LIMIT = COORD_LIMIT**2 + 2;
    type Area = uint(0..AREA_LIMIT);

    clk: in clock,
    rst: in async bool,

    sync(clk, rst) {
        input_points: interface axi_stream(Tuple(bool, Point)).input,
        output_area: interface axi_stream(Area).output,
    }
) {
    // shared ram
    wire ram_port_a: sync(clk, rst) interface uram_port(Point, MAX_POINT_COUNT);
    wire ram_port_b: sync(clk, rst) interface uram_port(Point, MAX_POINT_COUNT);
    instance uram(N=MAX_POINT_COUNT, T=Point, P=RAM_PIPELINE) ports(clk, rst, port_a=ram_port_a, port_b=ram_port_b);

    // front
    enum FrontState {
        Input,
        Calc,
        OutputBackReq,
        OutputBackWaitAck,
        OutputPushWait,
    }

    reg front_state: FrontState = FrontState.Input;
    reg front_point_count: uint(0..=MAX_POINT_COUNT) = 0;
    reg front_index_a: uint(0..MAX_POINT_COUNT) = 0;
    reg front_index_b: uint(0..MAX_POINT_COUNT) = 0;

    clocked(clk, async rst) {
        ram_port_a_write_address = Option.None;
        ram_port_a_write_data = Point.new(x=0, y=0);

        // input handshake
        if (input_points_ready && input_points.valid) {
            if (input_points.data.0) {
                assert_assume(front_point_count < MAX_POINT_COUNT);

                ram_port_a_write_address = Option.Some(front_point_count);
                ram_port_a_write_data = input_points.data.1;

                front_point_count += 1;
            } else {
                if (front_point_count <= 1) {
                    front_state = FrontState.OutputPushWait;
                } else {
                    front_index_a = 1;
                    front_index_b = 0;
                    front_state = FrontState.Calc;
                }
            }
        }

        // output handshake
        if (output_area_valid && output_area.ready) {
            output_area_valid = false;
        }

        // state machine
        input_points_ready = false;
        front_to_back_index_valid = false;
        front_to_back_req = false;

        match (front_state) {
            .Input => {
                input_points_ready = true;
            }
            .Calc => {
                // send calc packet
                front_to_back_index_valid = true;
                front_to_back_index_a = front_index_a;
                front_to_back_index_b = front_index_b;

                // increment indices, only visiting a triangle
                val new_index_b = front_index_b + 1;
                if (new_index_b == front_index_a) {
                    front_index_b = 0;

                    val new_index_a = front_index_a + 1;
                    if (new_index_a == front_point_count) {
                        front_state = FrontState.OutputBackReq;
                    } else {
                        assert_assume(front_index_a < MAX_POINT_COUNT - 1, "a");
                        front_index_a += 1;
                    }
                } else {
                    assert_assume(front_index_b < MAX_POINT_COUNT - 1, "b");
                    front_index_b += 1;
                }
            }
            .OutputBackReq => {
                // TODO skip this state, wa can inline this away
                front_to_back_req = true;
                front_state = FrontState.OutputBackWaitAck;
            }
            .OutputBackWaitAck => {
                if (back_to_front_ack) {
                    front_state = FrontState.OutputPushWait;
                }
            }
            .OutputPushWait => {
                if (!output_area_valid) {
                    var send_area = back_max_area;
                    if (send_area == 0 && front_point_count != 0) {
                        send_area = 1;
                    }

                    output_area_valid = true;
                    output_area_data = send_area;

                    front_state = FrontState.Input;
                }
            }
        }
    }

    // back pipeline
    struct BackState {
        valid: bool,
        req: bool,
    }
    fn reg_state(s: BackState) -> BackState {
        return reg(s, BackState.new(valid=false, req=false));
    }

    reg front_to_back_index_valid: bool = false;
    reg front_to_back_index_a: uint(0..MAX_POINT_COUNT) = undef;
    reg front_to_back_index_b: uint(0..MAX_POINT_COUNT) = undef;

    reg front_to_back_req: bool = false;
    reg back_to_front_ack: bool = false;

    reg back_max_area: Area = 0;

    clocked(clk, async rst) {
        var state = BackState.new(valid=front_to_back_index_valid, req=front_to_back_req);

        val pipe_index_a = reg(front_to_back_index_a, undef);
        val pipe_index_b = reg(front_to_back_index_b, undef);
        state = reg_state(state);

        if (state.valid) {
            ram_port_a_read_address = Option.Some(pipe_index_a);
            ram_port_b_read_address = Option.Some(pipe_index_b);
        } else {
            ram_port_a_read_address = Option.None;
            ram_port_b_read_address = Option.None;
        }
        for (_ in 0..RAM_PIPELINE + 3) {
            state = reg_state(state);
        }

        val pipe_point_a = reg(ram_port_a.read_data, undef);
        val pipe_point_b = reg(ram_port_b.read_data, undef);
        state = reg_state(state);

        val pipe_abs_a = reg(abs(pipe_point_a.x - pipe_point_b.x) + 1, undef);
        val pipe_abs_b = reg(abs(pipe_point_a.y - pipe_point_b.y) + 1, undef);
        state = reg_state(state);

        val pipe_mul = reg(pipe_abs_a * pipe_abs_b, undef);
        state = reg_state(state);

        if (state.valid) {
            back_max_area = max(back_max_area, pipe_mul);
        }
        back_to_front_ack = state.req;
    }

    // intermediate registers, we don't support interface registers yet
    reg input_points_ready: bool = false;
    reg output_area_valid: bool = false;
    reg output_area_data: Area = undef;

    reg ram_port_a_write_address: Option(uint(0..MAX_POINT_COUNT)) = Option.None;
    reg ram_port_a_write_data: sync(clk, rst) Point = undef;
    reg ram_port_a_read_address: sync(clk, rst) Option(uint(0..MAX_POINT_COUNT)) = Option.None;
    reg ram_port_b_read_address: sync(clk, rst) Option(uint(0..MAX_POINT_COUNT)) = Option.None;

    comb {
        input_points.ready = input_points_ready;
        output_area.valid = output_area_valid;
        output_area.data = output_area_data;

        ram_port_a.mem_enable = false;
        ram_port_a.write_enable = false;
        ram_port_a.address = 0;
        ram_port_a.write_data = Point.new(x=0, y=0);
        ram_port_b.mem_enable = false;
        ram_port_b.write_enable = false;
        ram_port_b.address = 0;
        ram_port_b.write_data = Point.new(x=0, y=0);

        match (ram_port_a_write_address) {
            .Some(val addr) => {
                ram_port_a.mem_enable = true;
                ram_port_a.write_enable = true;
                ram_port_a.address = addr;
                ram_port_a.write_data = ram_port_a_write_data;
            }
            .None => {
                match (ram_port_a_read_address) {
                    .Some(val addr) => {
                        ram_port_a.mem_enable = true;
                        ram_port_a.address = addr;
                    }
                    .None => {}
                }
            }
        }

        match (ram_port_b_read_address) {
            .Some(val addr) => {
                ram_port_b.mem_enable = true;
                ram_port_b.address = addr;
            }
            .None => {}
        }
    }
}
