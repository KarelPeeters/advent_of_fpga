import common.[char, Point as PointGeneral, axi_stream];
import string.[parse_points, int_to_chars];
import xilinx_uram.[uram, uram_port];

pub module core(
    MAX_POINT_COUNT: natural,
    COORD_LIMIT: natural,
    RAM_PIPELINE: natural,
    CORE_WIDTH: natural,
) ports(
    type Coord = uint(0..COORD_LIMIT);
    type Point = PointGeneral(Coord);
    const AREA_LIMIT = COORD_LIMIT**2 + 2;
    type Area = uint(0..AREA_LIMIT);

    clk: in clock,
    rst: in async bool,

    sync(clk, rst) {
        input_points: interface axi_stream(Tuple(bool, Point)).input,
        output_area: interface axi_stream(Area).output,
    }
) {
    // shared ram
    const RAM_DEPTH = ceil_div(MAX_POINT_COUNT, CORE_WIDTH);
    type RamWord = [CORE_WIDTH]Point;
    wire ram_port_a: sync(clk, rst) interface uram_port(RamWord, RAM_DEPTH);
    wire ram_port_b: sync(clk, rst) interface uram_port(RamWord, RAM_DEPTH);
    instance uram(N=RAM_DEPTH, T=RamWord, P=RAM_PIPELINE) ports(clk, rst, port_a=ram_port_a, port_b=ram_port_b);

    // front
    enum FrontState {
        Input,
        Calc,
        OutputBackReq,
        OutputBackWaitAck,
        OutputPushWait,
    }

    reg front_state: FrontState = FrontState.Input;
    reg front_point_count: uint(0..=MAX_POINT_COUNT) = 0;
    reg front_index_a: uint(0..RAM_DEPTH) = 0;
    reg front_index_b: uint(0..RAM_DEPTH) = 0;

    reg front_write_buffer: [CORE_WIDTH]Point = undef;
    reg front_write_level: uint(0..CORE_WIDTH) = 0;

    clocked(clk, async rst) {
        // output handshake
        if (output_area_valid && output_area.ready) {
            output_area_valid = false;
        }

        // state machine
        front_to_back_command = Option.None;
        front_to_back_req = false;

        match (front_state) {
            .Input => {
                // handled later
            }
            .Calc => {
                // send calc packet
                front_to_back_command = Option.Some(
                    Command.new(
                        index_a=front_index_a,
                        index_b=front_index_b,
                        mask_a=[front_index_a * CORE_WIDTH + i < front_point_count for i in 0..CORE_WIDTH],
                        mask_b=[front_index_b * CORE_WIDTH + i < front_point_count for i in 0..CORE_WIDTH],
                    ),
                );

                // increment indices, only visiting the triangle where `b <= a`
                val block_count = ceil_div(front_point_count, CORE_WIDTH);
                if (front_index_b == front_index_a) {
                    front_index_b = 0;

                    if (front_index_a == block_count - 1) {
                        front_state = FrontState.OutputBackReq;
                    } else {
                        assert_assume(front_index_a < RAM_DEPTH - 1);
                        front_index_a += 1;
                    }
                } else {
                    assert_assume(front_index_b < RAM_DEPTH - 1);
                    front_index_b += 1;
                }
            }
            .OutputBackReq => {
                front_to_back_req = true;
                front_state = FrontState.OutputBackWaitAck;
            }
            .OutputBackWaitAck => {
                if (back_to_front_ack) {
                    front_state = FrontState.OutputPushWait;
                }
            }
            .OutputPushWait => {
                if (!output_area_valid) {
                    var send_area = back_max_area;
                    if (send_area == 0 && front_point_count != 0) {
                        send_area = 1;
                    }

                    output_area_valid = true;
                    output_area_data = send_area;

                    front_state = FrontState.Input;
                    front_point_count = 0;
                }
            }
        }

        // input handshake, write to ram
        ram_port_a_write_address = Option.None;

        if (input_points_ready && input_points.valid) {
            if (input_points.data.0) {
                assert_assume(front_point_count < MAX_POINT_COUNT);

                // shift into buffer
                // We shift in at the low indices,
                //   this flips the order but means writing the partial words at the end is easier.
                front_write_buffer = [input_points.data.1, *front_write_buffer[0..CORE_WIDTH - 1]];

                // write to ram if buffer full
                if (front_write_level == CORE_WIDTH - 1) {
                    ram_port_a_write_address = Option.Some(front_point_count / CORE_WIDTH);
                    ram_port_a_write_data = front_write_buffer;
                    front_write_level = 0;
                } else {
                    front_write_level += 1;
                }

                front_point_count += 1;
            } else {
                // if anything left in buffer, write it to ram
                if (front_write_level > 0) {
                    assert_assume(front_point_count < MAX_POINT_COUNT);
                    ram_port_a_write_address = Option.Some(front_point_count / CORE_WIDTH);
                    ram_port_a_write_data = front_write_buffer;
                    front_write_level = 0;
                }

                // if nothing to calculate, go to output directly,
                //  otherwise start calculating
                if (front_point_count <= 1) {
                    front_state = FrontState.OutputPushWait;
                } else {
                    front_index_a = 0;
                    front_index_b = 0;
                    front_state = FrontState.Calc;
                }
            }
        }

        // input ready signal
        match (front_state) {
            .Input => {
                input_points_ready = true;
            }
            _ => {
                input_points_ready = false;
            }
        }
    }

    // back pipeline
    // TODO unify state and command into a single struct/enum?
    struct Command {
        index_a: uint(0..RAM_DEPTH),
        index_b: uint(0..RAM_DEPTH),
        mask_a: [CORE_WIDTH]bool,
        mask_b: [CORE_WIDTH]bool,
    }
    struct BackState {
        valid: bool,
        req: bool,
        mask_a: [CORE_WIDTH]bool,
        mask_b: [CORE_WIDTH]bool,
    }

    reg front_to_back_command: Option(Command) = Option.None;
    reg front_to_back_req: bool = false;
    reg back_to_front_ack: bool = false;

    // TODO reset this after handshake
    reg back_max_area: Area = 0;

    fn reg_state(s: BackState) -> BackState {
        val dummy = BackState.new(
            valid=false,
            req=false,
            mask_a=[false] * CORE_WIDTH,
            mask_b=[false] * CORE_WIDTH,
        );
        return reg(s, dummy);
    }

    clocked(clk, async rst) {
        var state;
        val pipe_index_a;
        val pipe_index_b;
        match (front_to_back_command) {
            .Some(val cmd) => {
                state = BackState.new(
                    valid=true,
                    req=front_to_back_req,
                    mask_a=cmd.mask_a,
                    mask_b=cmd.mask_b,
                );
                pipe_index_a = cmd.index_a;
                pipe_index_b = cmd.index_b;
            }
            .None => {
                state = BackState.new(
                    valid=true,
                    req=front_to_back_req,
                    mask_a=[false] * CORE_WIDTH,
                    mask_b=[false] * CORE_WIDTH,
                );
                pipe_index_a = 0;
                pipe_index_b = 0;
            }
        }

        if (state.valid) {
            ram_port_a_read_address = Option.Some(pipe_index_a);
            ram_port_b_read_address = Option.Some(pipe_index_b);
        } else {
            ram_port_a_read_address = Option.None;
            ram_port_b_read_address = Option.None;
        }
        for (_ in 0..RAM_PIPELINE + 3) {
            state = reg_state(state);
        }

        val pipe_word_a = reg(ram_port_a.read_data, undef);
        val pipe_word_b = reg(ram_port_b.read_data, undef);
        state = reg_state(state);

        val value_abs_x = [
            [abs((pipe_word_a[i]).x - (pipe_word_b[j]).x) + 1 for j in 0..CORE_WIDTH]
            for i in 0..CORE_WIDTH
        ];
        val value_abs_y = [
            [abs((pipe_word_a[i]).y - (pipe_word_b[j]).y) + 1 for j in 0..CORE_WIDTH]
            for i in 0..CORE_WIDTH
        ];

        val pipe_abs_x = reg(value_abs_x, undef);
        val pipe_abs_y = reg(value_abs_y, undef);
        state = reg_state(state);

        val value_mul = [[pipe_abs_x[i][j] * pipe_abs_y[i][j] for j in 0..CORE_WIDTH] for i in 0..CORE_WIDTH];
        val pipe_mul = reg(value_mul, undef);
        state = reg_state(state);

        if (state.valid) {
            // TODO tree reduction, or is there something even better?
            for (i in 0..CORE_WIDTH) {
                for (j in 0..CORE_WIDTH) {
                    if (state.mask_a[i] && state.mask_b[j]) {
                        back_max_area = max(back_max_area, pipe_mul[i][j]);
                    }
                }
            }
        }
        back_to_front_ack = state.req;
    }

    // intermediate registers, we don't support interface registers yet
    reg input_points_ready: bool = false;
    reg output_area_valid: bool = false;
    reg output_area_data: Area = undef;

    reg ram_port_a_write_address: Option(uint(0..RAM_DEPTH)) = Option.None;
    reg ram_port_a_write_data: sync(clk, rst) [CORE_WIDTH]Point = undef;
    reg ram_port_a_read_address: sync(clk, rst) Option(uint(0..RAM_DEPTH)) = Option.None;
    reg ram_port_b_read_address: sync(clk, rst) Option(uint(0..RAM_DEPTH)) = Option.None;

    comb {
        input_points.ready = input_points_ready;
        output_area.valid = output_area_valid;
        output_area.data = output_area_data;

        ram_port_a.mem_enable = false;
        ram_port_a.write_enable = false;
        ram_port_a.address = 0;
        ram_port_a.write_data = [Point.new(x=0, y=0)] * CORE_WIDTH;
        ram_port_b.mem_enable = false;
        ram_port_b.write_enable = false;
        ram_port_b.address = 0;
        ram_port_b.write_data = [Point.new(x=0, y=0)] * CORE_WIDTH;

        match (ram_port_a_write_address) {
            .Some(val addr) => {
                ram_port_a.mem_enable = true;
                ram_port_a.write_enable = true;
                ram_port_a.address = addr;
                ram_port_a.write_data = ram_port_a_write_data;
            }
            .None => {
                match (ram_port_a_read_address) {
                    .Some(val addr) => {
                        ram_port_a.mem_enable = true;
                        ram_port_a.address = addr;
                    }
                    .None => {}
                }
            }
        }

        match (ram_port_b_read_address) {
            .Some(val addr) => {
                ram_port_b.mem_enable = true;
                ram_port_b.address = addr;
            }
            .None => {}
        }
    }
}

const {
    core(MAX_POINT_COUNT=1024, COORD_LIMIT=2**8, RAM_PIPELINE=2, CORE_WIDTH=1);
    core(MAX_POINT_COUNT=1024, COORD_LIMIT=2**8, RAM_PIPELINE=2, CORE_WIDTH=2);
}
