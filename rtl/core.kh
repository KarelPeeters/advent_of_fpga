import common.[char, Point as PointGeneral, axi_stream];
import string.[parse_points, int_to_chars];
import xilinx_uram.[uram, uram_port];

const MAX_POINT_COUNT = 128;

pub module core(COORD_LIMIT: natural) ports(
    type Coord = uint(0..COORD_LIMIT);
    type Point = PointGeneral(Coord);
    const AREA_LIMIT = COORD_LIMIT**2 + 2;
    type Area = uint(0..AREA_LIMIT);

    clk: in clock,
    rst: in async bool,

    sync(clk, rst) {
        input_points: interface axi_stream(Tuple(bool, Point)).input,
        output_area: interface axi_stream(Area).output,
    }
) {
    // shared ram
    reg ram: [MAX_POINT_COUNT]Point = undef;

    // front
    enum FrontState {
        Input,
        Calc,
        OutputStart,
        OutputWait,
    }

    reg front_state: FrontState = FrontState.Input;
    reg front_point_count: uint(0..=MAX_POINT_COUNT) = 0;
    reg front_index_a: uint(0..MAX_POINT_COUNT) = 0;
    reg front_index_b: uint(0..MAX_POINT_COUNT) = 0;

    clocked(clk, async rst) {
        // input handshake
        if (input_points_ready && input_points.valid) {
            if (input_points.data.0) {
                assert_assume(front_point_count < MAX_POINT_COUNT);
                ram[front_point_count] = input_points.data.1;
                front_point_count += 1;
            } else {
                front_index_a = 0;
                front_index_b = 0;
                if (front_point_count == 0) {
                    front_state = FrontState.OutputStart;
                } else {
                    front_state = FrontState.Calc;
                }
            }
        }

        // state machine
        input_points_ready = false;
        pipe_index_valid = false;
        pipe_emit_output = false;

        match (front_state) {
            .Input => {
                input_points_ready = true;
            }
            .Calc => {
                // send calc packet
                pipe_index_valid = true;
                pipe_index_a = front_index_a;
                pipe_index_b = front_index_b;

                // increment indices
                val new_index_a = front_index_a + 1;
                if (new_index_a == front_point_count) {
                    front_index_a = 0;

                    val new_index_b = front_index_b + 1;
                    if (new_index_b == front_point_count) {
                        front_state = FrontState.OutputStart;
                    } else {
                        assert_assume(front_index_b < MAX_POINT_COUNT - 1);
                        front_index_b += 1;
                    }
                } else {
                    assert_assume(front_index_a < MAX_POINT_COUNT - 1);
                    front_index_a += 1;
                }
            }
            .OutputStart => {
                // TODO skip this state, wa can inline this away
                pipe_emit_output = true;
                front_state = FrontState.OutputWait;
            }
            .OutputWait => {
                if (pipe_emit_output_done) {
                    front_state = FrontState.Input;
                }
            }
        }
    }

    // pipeline/back
    reg pipe_index_valid: bool = false;
    reg pipe_index_a: uint(0..MAX_POINT_COUNT) = 0;
    reg pipe_index_b: uint(0..MAX_POINT_COUNT) = 0;

    reg pipe_emit_output: bool = false;
    reg pipe_emit_output_done: bool = false;

    reg back_max_area: Area = 0;

    clocked(clk, async rst) {
        // output handshake
        if (output_area_valid && output_area.ready) {
            output_area_valid = false;
            pipe_emit_output_done = true;
        }

        // push output
        if (pipe_emit_output) {
            assert(!output_area_valid);
            output_area_valid = true;
            output_area_data = back_max_area;
        }

        // pipeline
        if (pipe_index_valid) {
            val point_a = ram[front_index_a];
            val point_b = ram[front_index_b];

            // TODO map to DSP module, maybe fiddle with +- 1 a bit
            // TODO pipeline this, maybe abs/mul/max steps?
            val area = (abs(point_a.x - point_b.x) + 1) * (abs(point_a.y - point_b.y) + 1);
            back_max_area = max(back_max_area, area);
        }
    }

    // intermediate registers, we don't support interface registers yet
    reg input_points_ready: bool = false;
    reg output_area_valid: bool = false;
    reg output_area_data: Area = undef;
    comb {
        input_points.ready = input_points_ready;
        output_area.valid = output_area_valid;
        output_area.data = output_area_data;
    }
}
