import common.[char, Point as PointGeneral, axi_stream];
import string.[parse_points, int_to_chars];
import xilinx_uram.[uram, uram_port];

const MAX_POINT_COUNT = 128;

pub module core(COORD_LIMIT: natural) ports(
    type Coord = uint(0..COORD_LIMIT);
    type Point = PointGeneral(Coord);
    const AREA_LIMIT = COORD_LIMIT**2 + 2;
    type Area = uint(0..AREA_LIMIT);

    clk: in clock,
    rst: in async bool,

    sync(clk, rst) {
        input_points: interface axi_stream(Tuple(bool, Point)).input,
        output_area: interface axi_stream(Area).output,
    }
) {
    // shared ram
    reg ram: [MAX_POINT_COUNT]Point = undef;

    // front
    enum FrontState {
        Input,
        Calc,
        OutputStart,
        OutputWait,
    }

    reg front_state: FrontState = FrontState.Input;
    reg front_point_count: uint(0..=MAX_POINT_COUNT) = 0;
    reg front_index_a: uint(0..MAX_POINT_COUNT) = 0;
    reg front_index_b: uint(0..MAX_POINT_COUNT) = 0;

    clocked(clk, async rst) {
        // input handshake
        if (input_points_ready && input_points.valid) {
            if (input_points.data.0) {
                assert_assume(front_point_count < MAX_POINT_COUNT);
                ram[front_point_count] = input_points.data.1;
                front_point_count += 1;
            } else {
                if (front_point_count <= 1) {
                    front_state = FrontState.OutputStart;
                } else {
                    front_index_a = 1;
                    front_index_b = 0;
                    front_state = FrontState.Calc;
                }
            }
        }

        // state machine
        input_points_ready = false;
        pipe_index_valid = false;
        back_emit_output = Option.None;

        match (front_state) {
            .Input => {
                input_points_ready = true;
            }
            .Calc => {
                // send calc packet
                pipe_index_valid = true;
                pipe_index_a = front_index_a;
                pipe_index_b = front_index_b;

                // increment indices, only visiting a triangle
                val new_index_b = front_index_b + 1;
                if (new_index_b == front_index_a) {
                    front_index_b = 0;

                    val new_index_a = front_index_a + 1;
                    if (new_index_a == front_point_count) {
                        front_state = FrontState.OutputStart;
                    } else {
                        assert_assume(front_index_a < MAX_POINT_COUNT - 1, "a");
                        front_index_a += 1;
                    }
                } else {
                    assert_assume(front_index_b < MAX_POINT_COUNT - 1, "b");
                    front_index_b += 1;
                }
            }
            .OutputStart => {
                // TODO skip this state, wa can inline this away
                back_emit_output = Option.Some(front_point_count != 0);
                front_state = FrontState.OutputWait;
            }
            .OutputWait => {
                if (back_emit_output_done) {
                    front_state = FrontState.Input;
                }
            }
        }
    }

    // pipeline/back
    // TODO try this with register expressions
    const P = 3 + 1;
    reg pipe_index_valid: bool = false;
    reg pipe_index_a: uint(0..MAX_POINT_COUNT) = undef;
    reg pipe_index_b: uint(0..MAX_POINT_COUNT) = undef;

    reg pipe_point_valid: bool = false;
    reg pipe_point_a: Point = undef;
    reg pipe_point_b: Point = undef;

    reg pipe_abs_valid: bool = false;
    reg pipe_abs_a: uint(0..COORD_LIMIT + 1) = undef;
    reg pipe_abs_b: uint(0..COORD_LIMIT + 1) = undef;

    reg pipe_mul_valid: bool = false;
    reg pipe_mul: uint(0..AREA_LIMIT) = undef;

    reg back_emit_output: Option(bool) = Option.None;
    reg back_emit_output_delay: [P]Option(bool) = [Option(bool).None] * P;
    reg back_emit_output_done: bool = false;

    reg back_max_area: Area = 0;

    clocked(clk, async rst) {
        // output handshake
        if (output_area_valid && output_area.ready) {
            output_area_valid = false;
            back_emit_output_done = true;
        }

        // push output
        back_emit_output_delay = [*back_emit_output_delay[1..], back_emit_output];
        match (back_emit_output_delay[0]) {
            .Some(val any_points) => {
                var send_area = back_max_area;
                if (send_area == 0 && any_points) {
                    send_area = 1;
                }

                assert(!output_area_valid);
                output_area_valid = true;
                output_area_data = send_area;
            }
            .None => {}
        }

        // pipeline
        if (pipe_mul_valid) {
            back_max_area = max(back_max_area, pipe_mul);
        }

        pipe_mul_valid = pipe_abs_valid;
        pipe_mul = pipe_abs_a * pipe_abs_b;

        pipe_abs_valid = pipe_point_valid;
        pipe_abs_a = abs(pipe_point_a.x - pipe_point_b.x) + 1;
        pipe_abs_b = abs(pipe_point_a.y - pipe_point_b.y) + 1;

        pipe_point_valid = pipe_index_valid;
        pipe_point_a = ram[pipe_index_a];
        pipe_point_b = ram[pipe_index_b];
    }

    // intermediate registers, we don't support interface registers yet
    reg input_points_ready: bool = false;
    reg output_area_valid: bool = false;
    reg output_area_data: Area = undef;
    comb {
        input_points.ready = input_points_ready;
        output_area.valid = output_area_valid;
        output_area.data = output_area_data;
    }
}
