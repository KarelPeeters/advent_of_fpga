import common.[char, Point as PointGeneral, axi_stream];
import string.[parse_points, int_to_chars];
import xilinx_uram.[uram, uram_port];

const MAX_POINT_COUNT = 128;

pub module core(COORD_LIMIT: natural) ports(
    type Coord = uint(0..COORD_LIMIT);
    type Point = PointGeneral(Coord);
    const AREA_LIMIT = COORD_LIMIT**2 + 2;
    type Area = uint(0..AREA_LIMIT);

    clk: in clock,
    rst: in async bool,

    sync(clk, rst) {
        input_points: interface axi_stream(Tuple(bool, Point)).input,
        output_area: interface axi_stream(Area).output,
    }
) {
    // shared ram
    wire ram_port_a: sync(clk, rst) interface uram_port(Point, MAX_POINT_COUNT);
    wire ram_port_b: sync(clk, rst) interface uram_port(Point, MAX_POINT_COUNT);
    instance uram(N=MAX_POINT_COUNT, T=Point, P=3) ports(clk, rst, port_a=ram_port_a, port_b=ram_port_b);

    // front
    enum FrontState {
        Input,
        Calc,
        OutputStart,
        OutputWait,
    }

    reg front_state: FrontState = FrontState.Input;
    reg front_point_count: uint(0..=MAX_POINT_COUNT) = 0;
    reg front_index_a: uint(0..MAX_POINT_COUNT) = 0;
    reg front_index_b: uint(0..MAX_POINT_COUNT) = 0;

    clocked(clk, async rst) {
        ram_port_a_write_address = Option.None;
        ram_port_a_write_data = Point.new(x=0, y=0);

        // input handshake
        if (input_points_ready && input_points.valid) {
            if (input_points.data.0) {
                assert_assume(front_point_count < MAX_POINT_COUNT);

                ram_port_a_write_address = Option.Some(front_point_count);
                ram_port_a_write_data = input_points.data.1;

                front_point_count += 1;
            } else {
                if (front_point_count <= 1) {
                    front_state = FrontState.OutputStart;
                } else {
                    front_index_a = 1;
                    front_index_b = 0;
                    front_state = FrontState.Calc;
                }
            }
        }

        // state machine
        input_points_ready = false;
        pipe_index_valid = false;
        back_emit_output = Option.None;

        match (front_state) {
            .Input => {
                input_points_ready = true;
            }
            .Calc => {
                // send calc packet
                pipe_index_valid = true;
                pipe_index_a = front_index_a;
                pipe_index_b = front_index_b;

                // increment indices, only visiting a triangle
                val new_index_b = front_index_b + 1;
                if (new_index_b == front_index_a) {
                    front_index_b = 0;

                    val new_index_a = front_index_a + 1;
                    if (new_index_a == front_point_count) {
                        front_state = FrontState.OutputStart;
                    } else {
                        assert_assume(front_index_a < MAX_POINT_COUNT - 1, "a");
                        front_index_a += 1;
                    }
                } else {
                    assert_assume(front_index_b < MAX_POINT_COUNT - 1, "b");
                    front_index_b += 1;
                }
            }
            .OutputStart => {
                // TODO skip this state, wa can inline this away
                back_emit_output = Option.Some(front_point_count != 0);
                front_state = FrontState.OutputWait;
            }
            .OutputWait => {
                if (back_emit_output_done) {
                    front_state = FrontState.Input;
                }
            }
        }
    }

    // pipeline/back
    // TODO refactor this, especially the front/back handshake
    const P = 3 + 2 + 8;
    reg pipe_index_valid: bool = false;
    reg pipe_index_a: uint(0..MAX_POINT_COUNT) = undef;
    reg pipe_index_b: uint(0..MAX_POINT_COUNT) = undef;

    reg back_emit_output: Option(bool) = Option.None;
    reg back_emit_output_delay: [P]Option(bool) = [Option(bool).None] * P;
    reg back_emit_output_done: bool = false;

    reg back_max_area: Area = 0;

    clocked(clk, async rst) {
        // output handshake
        if (output_area_valid && output_area.ready) {
            output_area_valid = false;
            back_emit_output_done = true;
        }

        // push output
        back_emit_output_delay = [*back_emit_output_delay[1..], back_emit_output];
        match (back_emit_output_delay[0]) {
            .Some(val any_points) => {
                var send_area = back_max_area;
                if (send_area == 0 && any_points) {
                    send_area = 1;
                }

                assert(!output_area_valid);
                output_area_valid = true;
                output_area_data = send_area;
            }
            .None => {}
        }

        // pipeline
        var valid = pipe_index_valid;

        val pipe_index_a = reg(pipe_index_a, undef);
        val pipe_index_b = reg(pipe_index_b, undef);
        valid = reg(valid, false);

        if (valid) {
            ram_port_a_read_address = Option.Some(pipe_index_a);
            ram_port_b_read_address = Option.Some(pipe_index_b);
        } else {
            ram_port_a_read_address = Option.None;
            ram_port_b_read_address = Option.None;
        }
        valid = reg(valid, false);

        valid = reg(valid, false);
        valid = reg(valid, false);
        valid = reg(valid, false);
        valid = reg(valid, false);
        valid = reg(valid, false);

        val pipe_point_a = reg(ram_port_a.read_data, undef);
        val pipe_point_b = reg(ram_port_b.read_data, undef);
        valid = reg(valid, false);

        val pipe_abs_a = reg(abs(pipe_point_a.x - pipe_point_b.x) + 1, undef);
        val pipe_abs_b = reg(abs(pipe_point_a.y - pipe_point_b.y) + 1, undef);
        valid = reg(valid, false);

        val pipe_mul = reg(pipe_abs_a * pipe_abs_b, undef);
        valid = reg(valid, false);

        if (valid) {
            back_max_area = max(back_max_area, pipe_mul);
        }
    }

    // intermediate registers, we don't support interface registers yet
    reg input_points_ready: bool = false;
    reg output_area_valid: bool = false;
    reg output_area_data: Area = undef;

    reg ram_port_a_write_address: Option(uint(0..MAX_POINT_COUNT)) = Option.None;
    reg ram_port_a_write_data: sync(clk, rst) Point = undef;
    reg ram_port_a_read_address: sync(clk, rst) Option(uint(0..MAX_POINT_COUNT)) = Option.None;
    reg ram_port_b_read_address: sync(clk, rst) Option(uint(0..MAX_POINT_COUNT)) = Option.None;

    comb {
        input_points.ready = input_points_ready;
        output_area.valid = output_area_valid;
        output_area.data = output_area_data;

        ram_port_a.mem_enable = false;
        ram_port_a.write_enable = false;
        ram_port_a.address = 0;
        ram_port_a.write_data = Point.new(x=0, y=0);
        ram_port_b.mem_enable = false;
        ram_port_b.write_enable = false;
        ram_port_b.address = 0;
        ram_port_b.write_data = Point.new(x=0, y=0);

        match (ram_port_a_write_address) {
            .Some(val addr) => {
                ram_port_a.mem_enable = true;
                ram_port_a.write_enable = true;
                ram_port_a.address = addr;
                ram_port_a.write_data = ram_port_a_write_data;
            }
            .None => {
                match (ram_port_a_read_address) {
                    .Some(val addr) => {
                        ram_port_a.mem_enable = true;
                        ram_port_a.address = addr;
                    }
                    .None => {}
                }
            }
        }

        match (ram_port_b_read_address) {
            .Some(val addr) => {
                ram_port_b.mem_enable = true;
                ram_port_b.address = addr;
            }
            .None => {}
        }
    }
}
