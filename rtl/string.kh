import common.[axi_stream, Point, char, char_newline, char_comma, char_digit_0];

// Parse a stream of ascii characters into a stream of points.
// TODO expand to parse multiple values in parallel
pub module parse_points(
    // The maximum value of the coordinates (exclusive).
    M: natural,

    type Coord = uint(0..M);
    type Point = Point(Coord);
) ports(
    clk: in clock,
    rst: in async bool,

    sync(clk, rst) {
        input: interface axi_stream(char).input,
        output: interface axi_stream(Point).output,
    }
) {
    reg after_comma: bool = false;
    reg value_x: Coord = 0;
    reg value_y: Coord = 0;

    reg output_buffer_valid: bool = false;
    reg output_buffer_data: Point = undef;

    clocked(clk, async rst) {
        // input handshake
        if (input_ready && input.valid) {
            val c: char = input.data;
            match (c) {
                in char_digit_0..(char_digit_0 + 10) => {
                    val digit: int(0..10) = c - char_digit_0;
                    if (after_comma) {
                        assert_assume(value_y < M / 10, "value_y overflow");
                        value_y = value_y * 10 + digit;
                    } else {
                        assert_assume(value_x < M / 10, "value_x overflow");
                        value_x = value_x * 10 + digit;
                    }
                }
                char_comma => {
                    after_comma = true;
                }
                char_newline => {
                    assert(!output_buffer_valid);
                    output_buffer_valid = true;
                    output_buffer_data = Point.new(x=value_x, y=value_y);

                    value_x = 0;
                    value_y = 0;
                    after_comma = false;
                }
                _ => {
                    assert(false, "unexpected character {c}");
                }
            }
        }

        // output handshake
        if (output_valid && output.ready) {
            output_valid = false;
        }
        if (!output_valid) {
            output_valid = output_buffer_valid;
            output_data = output_buffer_data;
            output_buffer_valid = false;
        }

        // only accept new input if we have somewhere to put it
        input_ready = !output_buffer_valid;
    }

    // intermediate registers, we don't support interface registers yet
    reg input_ready: bool = false;
    reg output_valid: bool = false;
    reg output_data: Point = undef;
    comb {
        input.ready = input_ready;
        output.valid = output_valid;
        output.data = output_data;
    }
}

pub module int_to_chars(M: natural) ports(
    clk: in clock,
    rst: in async bool,

    sync(clk, rst) {
        input: interface axi_stream(uint(0..M)).input,
        output: interface axi_stream(char).output,
    }
) {
    const MAX_DIGITS = clog(10, M);
    enum State {
        AcceptInput,
        CalcDigits,
        EmitDigits,
    }

    reg state: State = State.AcceptInput;
    reg value: uint(0..M) = 0;
    reg digits: [MAX_DIGITS]uint(0..10) = [0] * MAX_DIGITS;
    reg digit_count: uint(0..MAX_DIGITS + 1) = 0;

    clocked(clk, async rst) {
        // input handshake
        if (input_ready && input.valid) {
            value = input.data;
            state = State.CalcDigits;
        }

        // output handshake
        if (output_valid && output.ready) {
            output_valid = false;
        }

        input_ready = false;
        match (state) {
            .AcceptInput => {
                input_ready = true;
            }
            .CalcDigits => {
                assert_assume(digit_count < MAX_DIGITS);

                val digit = value % 10;
                value = value / 10;
                digits = [digit, *digits[..MAX_DIGITS - 1]];
                digit_count += 1;

                if (value == 0) {
                    state = State.EmitDigits;
                }
            }
            .EmitDigits => {
                if (!output_valid) {
                    output_valid = true;

                    if (digit_count > 0) {
                        output_data = char_digit_0 + digits[0];
                        digits = [*digits[1..], 0];
                        digit_count -= 1;
                    } else {
                        output_data = char_newline;
                        state = State.AcceptInput;
                    }
                }
            }
        }
    }

    // intermediate registers, we don't support interface registers yet
    reg input_ready: bool = false;
    reg output_valid: bool = false;
    reg output_data: char = undef;
    comb {
        input.ready = input_ready;
        output.valid = output_valid;
        output.data = output_data;
    }
}

const {
    parse_points(10**5);
    int_to_chars(10**5);
}
