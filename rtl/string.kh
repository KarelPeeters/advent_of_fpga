import common.[axi_stream, Point, char, char_newline, char_comma, char_digit_0];
import std.math.ceil_div;

// Parse a stream of ascii characters into a stream of points.
// TODO expand to parse multiple values in parallel
pub module parse_points(
    // The maximum value of the coordinates (exclusive).
    M: natural,

    type Coord = uint(0..M);
    type Point = Point(Coord);
) ports(
    clk: in clock,
    rst: in async bool,

    sync(clk, rst) {
        input: interface axi_stream(char).input,
        // TODO this should really be Option(Point), but the python verilator wrapper does not really support that yet
        output: interface axi_stream(Tuple(bool, Point)).output,
    }
) {
    reg after_comma: bool = false;
    reg value_x: Coord = 0;
    reg value_y: Coord = 0;

    reg output_buffer_valid: bool = false;
    reg output_buffer_data: Tuple(bool, Point) = undef;

    clocked(clk, async rst) {
        // input handshake
        if (input_ready && input.valid) {
            val c: char = input.data;
            match (c) {
                in char_digit_0..(char_digit_0 + 10) => {
                    val digit: int(0..10) = c - char_digit_0;
                    if (after_comma) {
                        assert_assume(value_y < M / 10, "value_y overflow");
                        value_y = value_y * 10 + digit;
                    } else {
                        assert_assume(value_x < M / 10, "value_x overflow");
                        value_x = value_x * 10 + digit;
                    }
                }
                char_comma => {
                    after_comma = true;
                }
                char_newline => {
                    assert(!output_buffer_valid);
                    output_buffer_valid = true;
                    output_buffer_data = (true, Point.new(x=value_x, y=value_y));

                    value_x = 0;
                    value_y = 0;
                    after_comma = false;
                }
                0 => {
                    assert(!output_buffer_valid);
                    output_buffer_valid = true;
                    output_buffer_data = (false, Point.new(x=0, y=0));
                }
                _ => {
                    assert(false, "unexpected character {c}");
                }
            }
        }

        // output handshake
        if (output_valid && output.ready) {
            output_valid = false;
        }
        if (!output_valid) {
            output_valid = output_buffer_valid;
            output_data = output_buffer_data;
            output_buffer_valid = false;
        }

        // only accept new input if we have somewhere to put it
        input_ready = !output_buffer_valid;
    }

    // intermediate registers, we don't support interface registers yet
    reg input_ready: bool = false;
    reg output_valid: bool = false;
    reg output_data: Tuple(bool, Point) = undef;
    comb {
        input.ready = input_ready;
        output.valid = output_valid;
        output.data = output_data;
    }
}

pub module int_to_chars(M: natural) ports(
    clk: in clock,
    rst: in async bool,

    sync(clk, rst) {
        input: interface axi_stream(uint(0..M)).input,
        output: interface axi_stream(char).output,
    }
) {
    const MAX_DIGITS = clog(10, M);
    enum State {
        AcceptInput,
        CalcDigit0,
        CalcDigit1,
        EmitDigits,
    }

    reg state: State = State.AcceptInput;
    reg digits: [MAX_DIGITS]uint(0..10) = [0] * MAX_DIGITS;
    reg digit_count: uint(0..MAX_DIGITS + 1) = 0;

    const div_iterations = clog2(ceil_div(M, 10));
    reg div_counter: uint(0..=div_iterations) = 0;
    reg div_remainder: uint(0..M) = 0;
    reg div_result: [div_iterations]bool = [false] * div_iterations;
    reg div_sub: int(-10 * 2**(div_iterations - 1)..M) = 0;

    clocked(clk, async rst) {
        // input handshake
        if (input_ready && input.valid) {
            state = State.CalcDigit0;
            div_counter = 0;
            div_remainder = input.data;
            div_result = [false] * div_iterations;
        }

        // output handshake
        if (output_valid && output.ready) {
            output_valid = false;
        }

        input_ready = false;
        match (state) {
            .AcceptInput => {
                input_ready = true;
            }
            .CalcDigit0 => {
                if (div_counter < div_iterations) {
                    // start next division step
                    div_sub = div_remainder - 10 * 2**(div_iterations - div_counter - 1);
                    state = State.CalcDigit1;
                } else {
                    // save digit
                    assert_assume(div_remainder < 10, "remainder too large");
                    assert_assume(digit_count < MAX_DIGITS, "too many digits");
                    digits = [div_remainder, *digits[..MAX_DIGITS - 1]];
                    digit_count += 1;

                    val next_value = uint(div_iterations).from_bits(div_result);

                    if (next_value != 0) {
                        // start next digit calculation
                        div_counter = 0;
                        div_remainder = next_value;
                        div_result = [false] * div_iterations;
                    } else {
                        // done calculating digits
                        state = State.EmitDigits;
                    }
                }
            }
            .CalcDigit1 => {
                // finish step
                // TODO why did this need a separate pipeline stage,
                //   does vivado really not understand it can just look at the sign bit?
                val div_bit = div_sub >= 0;
                if (div_bit) {
                    div_remainder = div_sub;
                }
                div_result = [div_bit, *div_result[..div_iterations - 1]];

                assert_assume(div_counter < div_iterations, "div_counter overflow");
                div_counter += 1;

                state = State.CalcDigit0;
            }
            .EmitDigits => {
                if (!output_valid) {
                    output_valid = true;

                    if (digit_count > 0) {
                        output_data = char_digit_0 + digits[0];
                        digits = [*digits[1..], 0];
                        digit_count -= 1;
                    } else {
                        output_data = char_newline;
                        state = State.AcceptInput;
                    }
                }
            }
        }
    }

    // intermediate registers, we don't support interface registers yet
    reg input_ready: bool = false;
    reg output_valid: bool = false;
    reg output_data: char = undef;
    comb {
        input.ready = input_ready;
        output.valid = output_valid;
        output.data = output_data;
    }
}

const {
    parse_points(10**5);
    int_to_chars(10**5);
}
